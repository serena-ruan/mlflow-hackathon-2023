/** @jsxRuntime classic /
/** @jsx jsx */
import { jsx } from '@emotion/react';
import cx from 'classnames';
import { Children, Fragment, useEffect, useState, } from 'react';
import ErrorBoundary from '../../components/ErrorBoundary';
import * as breakpoints from '../../constants/breakpoints';
import { isBrowser } from '../../helpers';
import styles from './Section.css';
const TagWrapper = ({ background, children, index, isMobileSplitSection, isSplitSection, noPaddingBottom, noPaddingTop, reverseSection, splitSection, tag: CustomTag = 'section', ...other }) => {
    const { className: otherClassName, css: otherCss, ...otherProps } = other;
    const getBackground = () => {
        if (!isSplitSection) {
            if (background === 'light-grey')
                return 'uil-bgc-grey-100';
            if (background === 'black')
                return 'uil-bgc-grey-900';
            if (background === 'white')
                return 'uil-bgc-white';
        }
        return '';
    };
    const getMobileSplitSectionBackground = () => {
        if (reverseSection) {
            if (index === 0)
                return 'uil-bgc-grey-100';
            if (index === 1)
                return 'uil-bgc-grey-900';
        }
        if (index === 0)
            return 'uil-bgc-grey-900';
        return 'uil-bgc-grey-100';
    };
    const getSplitSectionBackground = () => {
        if (reverseSection) {
            return styles.reverseSplit;
        }
        return styles.split;
    };
    return (jsx(CustomTag, Object.assign({}, otherProps, { css: [
            !isSplitSection && background && styles[background],
            !isSplitSection && background === 'dark' && styles.dark,
            isSplitSection && getSplitSectionBackground(),
            otherCss,
        ], className: cx('uil-ph-16 uil-ff-poppins', isMobileSplitSection
            ? getMobileSplitSectionBackground()
            : getBackground(), !noPaddingBottom && 'uil-pb-48 lg:uil-pb-80', !noPaddingTop && 'uil-pt-48 lg:uil-pt-80', otherClassName) }),
        jsx("div", { className: cx('uil-mh-auto uil-pos-relative uil-z-2 uil-maw-500 md:uil-maw-1440', {
                'md:uil-d-grid md:uil-g-2 md:uil-ta-center': isSplitSection,
            }) }, children)));
};
const SectionWrapper = ({ background, children, noPaddingBottom, noPaddingTop, reverseSection, splitSection, tag, ...other }) => {
    const isSplitSection = splitSection || reverseSection;
    const [isMobile, setIsMobile] = useState(false);
    const checkMobile = () => {
        if (window.matchMedia(`(max-width: ${breakpoints.MD})`).matches) {
            setIsMobile(true);
        }
        else {
            setIsMobile(false);
        }
    };
    useEffect(() => {
        if (isBrowser) {
            checkMobile();
            window.addEventListener('resize', () => {
                checkMobile();
            });
        }
        return () => {
            window.removeEventListener('resize', () => {
                checkMobile();
            });
        };
    }, []);
    if (isSplitSection && Children.count(children) > 2)
        throw new Error('Only two children are allowed in the split Section component');
    if (isMobile && isSplitSection) {
        return (jsx(Fragment, null, Children.map(children, (item, index) => (jsx(TagWrapper, Object.assign({ key: index, background: background, index: index, isMobileSplitSection: true, isSplitSection: false, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), item)))));
    }
    return (jsx(TagWrapper, Object.assign({ background: background, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, isSplitSection: isSplitSection, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), children));
};
/** A `Section` is typically used when a new block of content starts at the page level. It usually comes with a `SectionHeader`. */
const Section = ({ background = 'light-grey', children, noPaddingBottom = false, noPaddingTop = false, reverseSection = false, splitSection = false, tag = 'section', ...other }) => {
    return (jsx(ErrorBoundary, null,
        jsx(SectionWrapper, Object.assign({ background: background, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), children)));
};
export default Section;
