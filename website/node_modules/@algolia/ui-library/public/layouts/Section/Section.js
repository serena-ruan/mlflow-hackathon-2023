"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @jsxRuntime classic /
/** @jsx jsx */
const react_1 = require("@emotion/react");
const classnames_1 = __importDefault(require("classnames"));
const react_2 = require("react");
const ErrorBoundary_1 = __importDefault(require("../../components/ErrorBoundary"));
const breakpoints = __importStar(require("../../constants/breakpoints"));
const helpers_1 = require("../../helpers");
const Section_css_1 = __importDefault(require("./Section.css"));
const TagWrapper = ({ background, children, index, isMobileSplitSection, isSplitSection, noPaddingBottom, noPaddingTop, reverseSection, splitSection, tag: CustomTag = 'section', ...other }) => {
    const { className: otherClassName, css: otherCss, ...otherProps } = other;
    const getBackground = () => {
        if (!isSplitSection) {
            if (background === 'light-grey')
                return 'uil-bgc-grey-100';
            if (background === 'black')
                return 'uil-bgc-grey-900';
            if (background === 'white')
                return 'uil-bgc-white';
        }
        return '';
    };
    const getMobileSplitSectionBackground = () => {
        if (reverseSection) {
            if (index === 0)
                return 'uil-bgc-grey-100';
            if (index === 1)
                return 'uil-bgc-grey-900';
        }
        if (index === 0)
            return 'uil-bgc-grey-900';
        return 'uil-bgc-grey-100';
    };
    const getSplitSectionBackground = () => {
        if (reverseSection) {
            return Section_css_1.default.reverseSplit;
        }
        return Section_css_1.default.split;
    };
    return (react_1.jsx(CustomTag, Object.assign({}, otherProps, { css: [
            !isSplitSection && background && Section_css_1.default[background],
            !isSplitSection && background === 'dark' && Section_css_1.default.dark,
            isSplitSection && getSplitSectionBackground(),
            otherCss,
        ], className: classnames_1.default('uil-ph-16 uil-ff-poppins', isMobileSplitSection
            ? getMobileSplitSectionBackground()
            : getBackground(), !noPaddingBottom && 'uil-pb-48 lg:uil-pb-80', !noPaddingTop && 'uil-pt-48 lg:uil-pt-80', otherClassName) }),
        react_1.jsx("div", { className: classnames_1.default('uil-mh-auto uil-pos-relative uil-z-2 uil-maw-500 md:uil-maw-1440', {
                'md:uil-d-grid md:uil-g-2 md:uil-ta-center': isSplitSection,
            }) }, children)));
};
const SectionWrapper = ({ background, children, noPaddingBottom, noPaddingTop, reverseSection, splitSection, tag, ...other }) => {
    const isSplitSection = splitSection || reverseSection;
    const [isMobile, setIsMobile] = react_2.useState(false);
    const checkMobile = () => {
        if (window.matchMedia(`(max-width: ${breakpoints.MD})`).matches) {
            setIsMobile(true);
        }
        else {
            setIsMobile(false);
        }
    };
    react_2.useEffect(() => {
        if (helpers_1.isBrowser) {
            checkMobile();
            window.addEventListener('resize', () => {
                checkMobile();
            });
        }
        return () => {
            window.removeEventListener('resize', () => {
                checkMobile();
            });
        };
    }, []);
    if (isSplitSection && react_2.Children.count(children) > 2)
        throw new Error('Only two children are allowed in the split Section component');
    if (isMobile && isSplitSection) {
        return (react_1.jsx(react_2.Fragment, null, react_2.Children.map(children, (item, index) => (react_1.jsx(TagWrapper, Object.assign({ key: index, background: background, index: index, isMobileSplitSection: true, isSplitSection: false, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), item)))));
    }
    return (react_1.jsx(TagWrapper, Object.assign({ background: background, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, isSplitSection: isSplitSection, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), children));
};
/** A `Section` is typically used when a new block of content starts at the page level. It usually comes with a `SectionHeader`. */
const Section = ({ background = 'light-grey', children, noPaddingBottom = false, noPaddingTop = false, reverseSection = false, splitSection = false, tag = 'section', ...other }) => {
    return (react_1.jsx(ErrorBoundary_1.default, null,
        react_1.jsx(SectionWrapper, Object.assign({ background: background, noPaddingBottom: noPaddingBottom, noPaddingTop: noPaddingTop, reverseSection: reverseSection, splitSection: splitSection, tag: tag }, other), children)));
};
exports.default = Section;
//# sourceMappingURL=Section.js.map